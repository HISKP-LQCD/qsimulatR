---
title: "Quantum Fourier Trafo"
author: "Carsten Urbach"
output:
  rmarkdown::html_vignette
    
vignette: >
  %\VignetteIndexEntry{qft}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r echo=FALSE}
library(knitr)
library(qsimulatR)
knitr::opts_chunk$set(fig.align='center',
                      comment='')
```

# Three qubit QFT

Let's take a normalised vector with eight components and Fourier transform it

```{r}
N <- 3
v <- seq(1:2^N)
v <- v/sqrt(sum(v^2))

w <- fft(v)/sqrt(length(v))
```

The same using the quantum Fourier Trafo. Note that we have to start
with the most significant bit, which in this case is qubit 3.

```{r}
y <- qstate(N, coefs=as.complex(v))
x <- H(3) * y
x <- cqgate(bits=c(2L, 3L), gate=S(3L)) * x
x <- cqgate(bits=c(1L, 3L), gate=Tgate(3L)) * x
x <- H(2) * x
x <- cqgate(bits=c(1L, 2L), gate=S(2L)) * x
x <- H(1) * x
x <- SWAP(c(1,3)) * x
```

The corresponding circuit looks as follows

```{r}
plot(x)
```

Now the coefficients of the state `x` should be the the Fourier
transform of the coefficients of `y`. The QFT is unitary

```{r}
sum(x@coefs*Conj(x@coefs))
```

and the coefficients match the one from the classical FFT up to re-ordering

```{r}
sqrt(sum((w - x@coefs)*Conj(w - x@coefs)))
```

# The inverse

Since the Hadamard gate is its own inverse, we need the hermitian
conjugates for `T` and `S`

```{r}
Tdagger <- function(bit) {
  return(methods::new("sqgate",
                      bit=as.integer(bit),
                      M=array(as.complex(c(1., 0, 0, exp(-1i*pi/4))), dim=c(2,2)),
                      type="Tdag"))
}
Sdagger <- function(bit) {
  return(methods::new("sqgate",
                      bit=as.integer(bit),
                      M=array(as.complex(c(1,0,0,-1i)), dim=c(2,2)),
                      type="Sdag"))
}
```

With these we can write the inverse
QFT as follows, again for three qubits

```{r}
z <- qstate(N, coefs=x@coefs)
z <- SWAP(c(1,3)) * z
z <- H(1) * z
z <- cqgate(bits=c(1L, 2L), gate=Sdagger(2L)) * z
z <- H(2) * z
z <- cqgate(bits=c(1L, 3L), gate=Tdagger(2L)) * z
z <- cqgate(bits=c(2L, 3L), gate=Sdagger(2L)) * z
z <- H(3) * z
```

```{r}
plot(z)
```

The coefficients can be compared with the original vector we started from

```{r}
sqrt(sum((v - z@coefs)*Conj(v - z@coefs)))
```
