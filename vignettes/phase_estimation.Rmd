---
title: "Phase Estimation Algorithm"
author: "Carsten Urbach"
output:
  rmarkdown::html_vignette
    
vignette: >
  %\VignetteIndexEntry{phase-estimation}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r echo=FALSE}
library(knitr)
library(qsimulatR)
knitr::opts_chunk$set(fig.align='center',
                      comment='')
```

## Rotation Matrix

We use a rotation matrix
\[
U\ =\ \begin{pmatrix}
c & s \\
-s & c \\
\end{pmatrix}
\]
with $c=\cos(\alpha)$, $s=\sin(\alpha)$ and a real-valued angle
$\alpha$ as an example. $U$ has eigenvalues
\[
\lambda_\pm\ =\ c\pm \mathrm{i} s\,.
\]
The corresponding eigenvectors are of the form
\[
u_\pm\ =\
\begin{pmatrix}
1 \\
\pm\mathrm{i}\\
\end{pmatrix}\,.
\]

## Phase Estimation

We use

```{r}
t=6
```

in the second register which allows us with probability $1-\epsilon$ to get the 
correct phase up to $t-\left\lceil \log\left(2+\frac{1}{2\epsilon}\right)\right\rceil$
digits. Let us choose

```{r}
epsilon <- 1/4
## note the log in base-2
digits <- t-ceiling(log(2+1/(2*epsilon))/log(2)) 
digits
```

and therefore expect an error of less than

```{r}
2^(-digits)
```

We start with qubit 1 in state $u_+$

```{r}
x <- S(1) * (H(1) * qstate(t+1, basis=""))
```

and we define the gate corresponding to $U$

```{r}
alpha <- pi*3/7
s <- sin(alpha)
c <- cos(alpha)
## note that R fills the matrix columns first
M <- array(as.complex(c(c, -s, s, c)), dim=c(2,2)) 
Uf <- sqgate(bit=1, M=M, type=paste0("Uf"))
```

Now we apply the Hadamard gate to qubits 2,\dots,t+1

```{r}
for(i in c(2:(t+1))) {
  x <- H(i) * x
}
```

and the controlled $U_f$

```{r}
for(i in c(2:(t+1))) {
  x <- cqgate(bits=c(i, 1),
              gate=sqgate(bit=1,
                          M=M, type=paste0("Uf", 2^(i-2)))) * x
  M <- M %*% M
}
plot(x)
```

Next we apply the inverse Fourier transformation

```{r, fig.width=9, fig.height=4}
x <- qft(x, inverse=TRUE, bits=c(2:(t+1)))
plot(x)
```

$x$ is now the state
$|\tilde\varphi\rangle|u\rangle$. $\tilde\varphi\rangle$ is not neccessarily
a pure state. The next step is a projective measurement of
$|\tilde\varphi\rangle$

```{r}
xtmp <- measure(x)
cbits <- genStateNumber(which(xtmp@coefs==1), t+1)
phi <- sum(cbits[1:t]/2^(1:t))

cbits[1:t]
phi
```

We find that usually

```{r}
phi-alpha/(2*pi)
```

is indeed smaller than the maximal deviation $2^{-\mathrm{digits}}=$
`r 2^(-digits)` we expect.
