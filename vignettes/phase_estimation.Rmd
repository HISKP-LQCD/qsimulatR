---
title: "Phase Estimation Algorithm"
author: "Carsten Urbach"
output:
  rmarkdown::html_vignette
    
vignette: >
  %\VignetteIndexEntry{phase-estimation}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r echo=FALSE}
library(knitr)
library(qsimulatR)
knitr::opts_chunk$set(fig.align='center',
                      comment='')
```

## Rotation Matrix

We use a rotation matrix
\[
U\ =\ \begin{pmatrix}
c & s \\
-s & c \\
\end{pmatrix}
\]
with $c=\cos(\alpha)$, $s=\sin(\alpha)$ and a real-valued angle
$\alpha$ as an example. $U$ has eigenvalues
\[
\lambda_\pm\ =\ c\pm \mathrm{i} s\,.
\]
The corresponding eigenvectors are of the form
\[
u_\pm\ =\
\begin{pmatrix}
1 \\
\mp\mathrm{i}\\
\end{pmatrix}\,.
\]

## Phase Estimation

We start with qubit 1 in state $u_+$ and use
```{r}
t=4
```

in the second register

```{r}
x <- S(1) * (H(1) * qstate(t+1))
```

And we define the gate corresponding to $U$

```{r}
alpha <- pi*3/8
s <- sin(alpha)
c <- cos(alpha)
M <- array(as.complex(c(c, s, -s, c)), dim=c(2,2))
Uf <- sqgate(bit=1, M=M, type=paste0("Uf"))
```

Now we apply the Hadamard gate to qubits 2,\dots,t+1

```{r}
for(i in c(2:(t+1))) {
  x <- H(i) * x
}
```

and the controlled $U_f$

```{r}
for(i in c(2:(t+1))) {
  x <- cqgate(bits=c(i, 1),
              gate=sqgate(bit=1,
                          M=M, type=paste0("Uf", 2^(i-2)))) * x
  M <- M %*% M
}
plot(x)
```

Next we apply the inverse Fourier transformation

```{r}
x <- qft(x, inverse=TRUE, bits=c(2:(t+1)))
plot(x)
```

and measure

```{r}
cbits <- c()
phi <- 0.
reg <- c(2:(t+1))
for(i in seq_along(reg)) {
  cbits[i] <- measure(x, reg[i])$value
}
N <- length(reg)
for(i in seq_along(reg)) {
  phi <- phi + cbits[i]/2^(N-i+1)
}

phi.plus <- 2*pi*phi
phi.minus <- 2*pi*(1-phi)

cbits
phi.plus
phi.minus
alpha
```
